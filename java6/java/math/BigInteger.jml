// @(#)$Id: BigInteger.refines-spec 1388 2005-05-05 00:40:33Z davidcok $

// Copyright (C) 2001 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package java.math;

import java.util.Random;

// FIXME
/** JML's specification of java.math.BigInteger.
 *
 * @version $Revision: 1388 $
 * @author David R. Cok
 * @author Gary T. Leavens
 */
//+OPENJML@ immutable
//@ non_null_by_default
public /*@ pure @*/ class BigInteger extends Number implements Comparable {

    /*@
        public static model pure BigInteger parse(String val, int radix) {
		// !FIXME! - should put in a non-circular computation
		return new BigInteger(val,radix);
	}
        public static model pure BigInteger convert(byte[] val) {
		// !FIXME! - should put in a non-circular computation
		return new BigInteger(val);
	}
    @*/

    //-RAC@ public model \bigint value; in objectState;
    //-RAC@ public model int sign;
    //-RAC@ public represents sign = signum();


    /*@ public normal_behavior
      @     requires val != null;
      @     requires val.length != 0;
      @     ensures (* value and sign are what? *);
      @  also public exceptional_behavior
      @     requires val != null;
      @     requires val.length == 0;
      @     signals_only java.lang.NumberFormatException;
      @  also public exceptional_behavior
      @     requires val == null;
      @     signals_only java.lang.NullPointerException;
      @*/
    //@ pure
    public BigInteger(/*@ nullable @*/ byte[] val);

    /*-RAC@ public normal_behavior
      @    requires magnitude != null;
      @    requires signum == 0 || signum == 1 || signum == -1;
      @    requires signum == 0 <==> convert(magnitude).equals(ZERO);
      @    ensures (* value and sign are what? *);
      @    ensures sign == signum;
      @*/
    //@ pure
    public BigInteger(int signum, /*@ non_null @*/ byte[] magnitude);

    /*-RAC@  public normal_behavior
      @     requires val != null && !val.equals("");
      @     requires radix > 1;
      @     ensures this.equals(parse(val,radix));
      @ also
      @   public exceptional_behavior
      @     requires val != null && val.equals("");
      @     signals_only java.lang.NumberFormatException;
      @ also
      @   public exceptional_behavior
      @     requires val == null;
      @     signals_only java.lang.NullPointerException;
      @*/
    //@ pure
    public BigInteger(String val, int radix);

    /*@ normal_behavior
      @    ensures true;
      @*/
    //@ pure
    BigInteger(char[] val);

    /*-RAC@  public normal_behavior
      @     requires val != null && !val.equals("");
      @     ensures this.equals(parse(val,10));
      @ also
      @   public exceptional_behavior
      @     requires val.equals("");
      @     signals_only java.lang.NumberFormatException;
      @ also
      @   public exceptional_behavior
      @     requires val == null;
      @     signals_only java.lang.NullPointerException;
      @*/
    //@ pure
    public BigInteger(String val);

    //@ pure
    public BigInteger(int numBits, Random rnd);

    //@ pure
    public BigInteger(int bitLength, int certainty, Random rnd);

    // FIXME - when bigint is not equivalent to long  //@ model pure public BigInteger(\bigint val);

    public static /*@ pure @*/ BigInteger probablePrime(int bitLength,
                                                          Random rnd);

    boolean primeToCertainty(int certainty, java.util.Random r); // CHANGED in 1.6

    private static int jacobiSymbol(int p, BigInteger n);

    // BigInteger(MutableBigInteger val, int sign);

    //Static Factory Methods

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result.value == val;
    public static /*@ pure function @*/ BigInteger valueOf(long val);

    // int signum;   package-level field removed from specification (dmz, 2009-11-17)
    // int[] mag;    package-level field removed from specification (dmz, 2009-11-17)
    public static final BigInteger ZERO;
    public static final BigInteger ONE;
    
    //@ axiom ZERO.value == 0;
    //@ axiom ONE.value == 1;

    // @ public invariant ZERO != null && ZERO.longValue() == 0L;
    // @ public invariant ZERO.equals(ZERO);
    // @ public constraint ZERO == \old(ZERO);
    // @ public invariant ONE != null && ONE.longValue() == 1L;
    // @ public invariant ONE.equals(ONE);
    // @ public invariant !ZERO.equals(ONE);
    // @ public constraint ONE == \old(ONE);

    // Arithmetic Operations

    //@ public normal_behavior
    //-RAC@ ensures \result.value == this.value + val.value;
    //@ pure
    public BigInteger add(BigInteger val);

    //@ public normal_behavior
    //-RAC@ ensures \result.value == this.value - val.value;
    //@ pure
    public BigInteger subtract(BigInteger val);

    //@ public normal_behavior
    //-RAC@ ensures \result.value == this.value * val.value;
    //@ pure
    public BigInteger multiply(BigInteger val);

    //@ public normal_behavior
    //-RAC@ requires val.value != 0;
    //-RAC@ ensures \result.value == this.value / val.value;
    //@ pure
    public BigInteger divide(BigInteger val);

    //@ ensures \result[0].equals(divide(val));
    //@ ensures \result[1].equals(remainder(val));
    public BigInteger[] divideAndRemainder(BigInteger val);

    public BigInteger remainder(BigInteger val);

    public BigInteger pow(int exponent);

    public BigInteger gcd(BigInteger val);

    static void primitiveRightShift(int[] a, int len, int n);

    static void primitiveLeftShift(int[] a, int len, int n);

    //@ assignable \nothing;
    //@ ensures \result.signum() >= 0 && (sign==0 ==> \result.signum() == 0);
    public BigInteger abs();

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result.value == -value;
    //@ pure function
    public BigInteger negate();

    //-RAC@ public normal_behavior
    //-RAC@   ensures value == 0 ? 0 : value > 0 ? 1 : -1;
    //@ pure function
    public int signum();

    // Modular Arithmetic Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger mod(BigInteger m);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger modPow(BigInteger exponent, BigInteger m);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    static int[] bnExpModThreshTable;

    static int mulAdd(int[] out, int[] in, int offset, int len, int k);

    static int addOne(int[] a, int offset, int mlen, int carry);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger modInverse(BigInteger m);

    // Shift Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger shiftLeft(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger shiftRight(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    int[] javaIncrement(int[] val);

    // Bitwise Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger and(BigInteger val);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger or(BigInteger val);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger xor(BigInteger val);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger not();

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger andNot(BigInteger val);

    // Single Bit Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public boolean testBit(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger setBit(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger clearBit(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public BigInteger flipBit(int n);

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public int getLowestSetBit();

    // Miscellaneous Bit Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public int bitLength();

    // static int bitLen(int w);   package-level method removed from specification (dmz, 2009-11-17)

    // static final byte[] trailingZeroTable;   package-level array removed from specification (dmz, 2009-11-17)

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public int bitCount();

    // static int bitCnt(int val);   package-level method removed from specification (dmz, 2009-11-17)

    // static int trailingZeroCnt(int val);   package-level method removed from specification (dmz, 2009-11-17)

    // Primality Testing

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public boolean isProbablePrime(int certainty);

    // Comparison Operations

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result == (value == val.value ? 0 : value < val.value ? -1: 1);
    //-RAC@ pure
    public int compareTo(BigInteger val);

    /*@ also public normal_behavior
      @   requires x != null && x instanceof BigInteger;
      @   assignable \nothing;
      @   ensures \result == (value == ((BigInteger)x).value);
      @*/
    public /*@ pure helper @*/ boolean equals(Object x);

    //-RAC@ public normal_behavior
    //-RAC@   ensures this.value < val.value ? \result.value == this.value : \result.value == val.value;
    //@ pure function
    public BigInteger min(BigInteger val);

    //-RAC@ public normal_behavior
    //-RAC@   ensures this.value > val.value ? \result.value == this.value : \result.value == val.value;
    //@ pure function
    public BigInteger max(BigInteger val);

    // Hash Function

    //-RAC@ public normal_behavior
    //-RAC@   ensures true; // FIXME - add detail
    //@ pure function
    public int hashCode();

    //@  ensures \result != null;
    //-RAC@ ensures  parse(\result,radix).equals(this);
    public String toString(int radix);

    //@ also
    //@ ensures \result != null;
    //-RAC@ ensures  parse(\result,10).equals(this);
    public String toString();

    //@ ensures convert(\result).equals(this);
    //@ pure helper
    public byte[] toByteArray();

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result == (int)value; // FIXME - what about overflow?
    //@ pure function
    public int intValue();

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result == (long)value; // FIXME - what about overflow?
    //@ pure function
    public long longValue();

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result == (float)value; // FIXME - what about overflow?
    //@ pure function
    public float floatValue();

    //-RAC@ public normal_behavior
    //-RAC@   ensures \result == (double)value; // FIXME - what about overflow?
    //@ pure function
    public double doubleValue();

}
