package java.nio;
public abstract class Buffer {
  static final int SPLITERATOR_CHARACTERISTICS;
  /*@ spec_public */ private int mark;
  /*@ spec_public */ private int position;
  /*@ spec_public */ private int limit;
  /*@ spec_public */ private int capacity;
  /*@ spec_public */ long address;
  //-RAC@ public model boolean markSet = false;
  
  //-RAC@ public invariant 0 <= capacity;
  //-RAC@ public invariant 0 <= limit && limit <= capacity;
  //-RAC@ public invariant 0 <= position && position <= limit;
  //-RAC@ public invariant markSet ==> (0 <= mark && mark <= position);
  
  /*-RAC@
   @   // FIXME _ need something here
   @*/
  Buffer(int a, int b, int c, int d);
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures \result == capacity;
  //-RAC@ pure
  public final int capacity();
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures \result == position;
  //-RAC@ pure
  public final int position();
  
  //-RAC@ public normal_behavior
  //-RAC@   requires 0 <= p && p <= limit;
  //-RAC@   assignable position, markSet;
  //-RAC@   ensures position == p;
  //-RAC@   ensures (\old(markSet) && mark > p) ==> !markSet;
  //-RAC@   ensures \result == this;
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !(0 <= p && p <= limit);
  //-RAC@   signals (IllegalArgumentException e) true; // FIXME - improve this
  public final Buffer position(int p);
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures \result == limit;
  //-RAC@ pure
  public final int limit();
  
  //-RAC@ public normal_behavior
  //-RAC@   requires 0 <= limit && limit <= capacity;
  //-RAC@   assignable markSet, position, limit;
  //-RAC@   ensures limit == p;
  //-RAC@   ensures \old(position) > limit ==> position == limit;
  //-RAC@   ensures \old(mark) > limit ==> !markSet;
  //-RAC@   ensures \result == this;
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !(0 <= limit && limit <= capacity);
  //-RAC@   signals (IllegalArgumentException e) true;  // FIXME - improve this
  public final Buffer limit(int p);

  //-RAC@ public normal_behavior
  //-RAC@   assignable mark, markSet;
  //-RAC@   ensures markSet && mark == position;
  //-RAC@   ensures \result == this;
  public final Buffer mark();

  //-RAC@ public normal_behavior
  //-RAC@   requires markSet;
  //-RAC@   assignable position, mark, markSet;
  //-RAC@   ensures position == mark && !markSet;
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !markSet;
  //-RAC@   signals (InvalidMarkException e) true;  // FIXME - improve this
  public final Buffer reset();
  
  //-RAC@ public normal_behavior
  //-RAC@   assignable mark, markSet, position, limit; // FIXME - possibly resets the contents
  //-RAC@   ensures !markSet && position == 0 && limit == capacity;
  //-RAC@   ensures \result == this;
  public final Buffer clear();
  
  //-RAC@ public normal_behavior
  //-RAC@   assignable mark, markSet, position, limit;
  //-RAC@   ensures !markSet && position == 0 && limit == \old(position);
  //-RAC@   ensures \result == this;
  public final Buffer flip();
  
  //-RAC@ public normal_behavior
  //-RAC@  assignable markSet, position;
  //-RAC@  ensures !markSet && position == 0 ;
  //-RAC@  ensures \result == this;
  public final Buffer rewind();

  //-RAC@ public normal_behavior
  //-RAC@   ensures \result == (limit - position);
  //-RAC@ pure
  public final int remaining();

  //-RAC@ public normal_behavior
  //-RAC@   ensures \result == (limit != position);
  //-RAC@ pure
  public final boolean hasRemaining();
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures true;  // Implemented by overrides
  //-RAC@ pure
  public abstract boolean isReadOnly();
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures isReadOnly() ==> !\result;
  //-RAC@   ensures (* model whether tdhere is an array *);
  //-RAC@ pure
  public abstract boolean hasArray();
  
  //-RAC@ public normal_behavior
  //-RAC@   requires hasArray() && isReadOnly();
  //-RAC@   ensures true;
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasArray() || !isReadOnly();
  //-RAC@   signals (ReadOnlyBufferException e) !isReadOnly();
  //-RAC@   signals (UnsupportedOperationException e) !hasArray();
  //-RAC@ pure
  public abstract java.lang.Object array();
  
  //-RAC@ public normal_behavior
  //-RAC@   requires hasArray() && isReadOnly();
  //-RAC@   ensures (* offest within the backing buffer *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasArray() || !isReadOnly();
  //-RAC@   signals (ReadOnlyBufferException e) !isReadOnly();
  //-RAC@   signals (UnsupportedOperationException e) !hasArray();
  //-RAC@ pure
  public abstract int arrayOffset();
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures true;  // FIXME - model whether buffer is direct
  //-RAC@ pure
  public abstract boolean isDirect();
  
  /*
  final int nextGetIndex();
  
  final int nextGetIndex(int);
  
  final int nextPutIndex();
  
  final int nextPutIndex(int);
  final int checkIndex(int);
  final int checkIndex(int, int);
  final int markValue();
  final void truncate();
  final void discardMark();
  static void checkBounds(int, int, int);
  */
}
