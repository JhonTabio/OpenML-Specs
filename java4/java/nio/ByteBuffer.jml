package java.nio;

//@ non_null_by_default
public abstract class ByteBuffer extends Buffer implements java.lang.Comparable<ByteBuffer> {/*@ spec_public */ final byte[] hb;/*@ spec_public */ final int offset;
  /*@ spec_public */ boolean isReadOnly;
  /*@ spec_public */ boolean bigEndian;
  /*@ spec_public */ boolean nativeByteOrder;
  
  //-RAC@ normal_behavior
  //-RAC@   ensures (* somethign *);
  ByteBuffer(int a, int b, int c, int d, byte[] bb, int e);

  //-RAC@ normal_behavior
  //-RAC@   ensures (* something *);
  ByteBuffer(int a, int b, int s, int d);
  
  public static ByteBuffer allocateDirect(int n);
  
  //-RAC@ public normal_behavior
  //-RAC@   ensures \result.capacity == c;
  //-RAC@   ensures \result.limit == c;
  //-RAC@   ensures \result.position == 0;
  //-RAC@   ensures \result.markSet == false;
  //-RAC@ pure
  public static ByteBuffer allocate(int c);
  
  //-RAC@ public normal_behavior
  //-RAC@   requires 0 <= offset && 0 <= length && offset + length <= b.length;
  //-RAC@   ensures \result.capacity == b.length;
  //-RAC@   ensures \result.limit == offset + length;
  //-RAC@   ensures \result.position == offset;
  //-RAC@   ensures \result.markSet == false;
  //-RAC@ also public exceptional_behavior 
  //-RAC@   requires !(0 <= offset && 0 <= length && offset + length <= b.length);
  //-RAC@ also public code exceptional_behavior 
  //-RAC@   requires !(0 <= offset && 0 <= length && offset + length <= b.length);
  //-RAC@   signals_only IndexOutOfBoundsException;
  //-RAC@ pure
  public static ByteBuffer wrap(byte[] b, int offset, int length);

  //-RAC@ public normal_behavior
  //-RAC@   ensures \result.capacity == b.length;
  //-RAC@   ensures \result.limit == b.length;
  //-RAC@   ensures \result.position == 0;
  //-RAC@   ensures \result.markSet == false;
  //-RAC@ pure
  public static ByteBuffer wrap(byte[] b);
  
  // FIXME
  public abstract ByteBuffer slice();
  
  // FIXME
  public abstract ByteBuffer duplicate();
  
  // FIXME
  public abstract ByteBuffer asReadOnlyBuffer();
  
  //-RAC@ public normal_behavior
  //-RAC@   requires hasRemaining();
  //-RAC@   assignable position;
  //-RAC@   ensures position == \old(position) + 1;
  //-RAC@   ensures (* correct output *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferUnderflowException;
  public abstract byte get();

  //-RAC@ public normal_behavior
  //-RAC@   requires hasRemaining();
  //-RAC@   assignable position;
  //-RAC@   ensures position == \old(position) + 1;
  //-RAC@   ensures (* modified contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferOverflowException;
  public abstract ByteBuffer put(byte b);

  //-RAC@ public normal_behavior
  //-RAC@   requires hasRemaining();
  //-RAC@   ensures (* get contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   signals_only BufferUnderflowException;
  //-RAC@ pure
  public abstract byte get(int p);

  //-RAC@ public normal_behavior
  //-RAC@   requires hasRemaining();
  //-RAC@   assignable \nothing; // FIXME
  //-RAC@   ensures (* modify contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !hasRemaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferOverflowException;
  public abstract ByteBuffer put(int p, byte b);

  //-RAC@ public normal_behavior
  //-RAC@   requires 0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining();
  //-RAC@	assignable position, b[offset .. (offset+length-1)];
  //-RAC@   ensures position == \old(position) + length;
  //-RAC@   ensures (* get contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !(0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining());
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !(0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining());
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferUnderflowException, IndexOutOfBoundsException;
  //-RAC@   signals (BufferUnderflowException e) !(length <= remaining());
  //-RAC@   signals (IndexOutOfBoundsException e) !(0 <= offset && 0 <= length && offset+length <= b.length);
  public ByteBuffer get(byte[] b, int offset, int length);

  //-RAC@ public normal_behavior
  //-RAC@   requires b.length <= remaining();
  //-RAC@	assignable position, b[*];
  //-RAC@   ensures position == \old(position) + b.length;
  //-RAC@   ensures (* get contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires b.length > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires b.length > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferUnderflowException;
  public ByteBuffer get(byte[] b);
  
  //-RAC@ public normal_behavior
  //-RAC@   old int n = src.remaining();
  //-RAC@   requires n <= remaining();
  //-RAC@   assignable src.position, position; // FIXME
  //-RAC@   ensures src.position == \old(src.position) + n;
  //-RAC@   ensures position == \old(position) + n;
  //-RAC@   ensures (* modify contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires src.remaining() > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires src.remaining() > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferOverflowException;
  public ByteBuffer put(ByteBuffer src);

  //-RAC@ public normal_behavior
  //-RAC@   requires 0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining();
  //-RAC@	assignable position; // FIXME
  //-RAC@   ensures position == \old(position) + length;
  //-RAC@   ensures (* modified contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires !(0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining());
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires !(0 <= offset && 0 <= length && offset+length <= b.length && length <= remaining());
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferOverflowException, IndexOutOfBoundsException;
  //-RAC@   signals (BufferOverflowException e) !(length <= remaining());
  //-RAC@   signals (IndexOutOfBoundsException e) !(0 <= offset && 0 <= length && offset+length <= b.length);
  public ByteBuffer put(byte[] b, int offset, int length);

  //-RAC@ public normal_behavior
  //-RAC@   requires b.length <= remaining();
  //-RAC@   assignable position; // FIXME
  //-RAC@   ensures position == \old(position) + b.length;
  //-RAC@   ensures (* modify contents *);
  //-RAC@ also public exceptional_behavior
  //-RAC@   requires b.length > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@ also public code exceptional_behavior
  //-RAC@   requires b.length > remaining();
  //-RAC@   assignable \nothing;
  //-RAC@   signals_only BufferOverflowException;
  public final ByteBuffer put(byte[] b);
  
  // FIXME - do the rest
  
  public final boolean hasArray();
  public final byte[] array();
  public final int arrayOffset();
  public abstract ByteBuffer compact();
  public abstract boolean isDirect();
  public java.lang.String toString();
  public int hashCode();
  public boolean equals(java.lang.Object o);
  private static boolean equals(byte b, byte bb);
  public int compareTo(ByteBuffer  buf);
  private static int compare(byte b, byte bb);
  public final ByteOrder order();
  public final ByteBuffer order(java.nio.ByteOrder order);
  abstract byte _get(int p);
  abstract void _put(int p, byte b);
  
  
  public abstract char getChar();
  public abstract java.nio.ByteBuffer putChar(char c);
  public abstract char getChar(int c);
  public abstract java.nio.ByteBuffer putChar(int offset, char c);
  public abstract java.nio.CharBuffer asCharBuffer();
  public abstract short getShort();
  public abstract java.nio.ByteBuffer putShort(short n);
  public abstract short getShort(int n);
  public abstract java.nio.ByteBuffer putShort(int p, short n);
  public abstract java.nio.ShortBuffer asShortBuffer();
  public abstract int getInt();
  public abstract java.nio.ByteBuffer putInt(int n);
  public abstract int getInt(int n);
  public abstract java.nio.ByteBuffer putInt(int n, int nn);
  public abstract java.nio.IntBuffer asIntBuffer();
  public abstract long getLong();
  public abstract java.nio.ByteBuffer putLong(long n);
  public abstract long getLong(int n);
  public abstract java.nio.ByteBuffer putLong(int n, long nn);
  public abstract java.nio.LongBuffer asLongBuffer();
  public abstract float getFloat();
  public abstract java.nio.ByteBuffer putFloat(float f);
  public abstract float getFloat(int p);
  public abstract java.nio.ByteBuffer putFloat(int p, float f);
  public abstract java.nio.FloatBuffer asFloatBuffer();
  public abstract double getDouble();
  public abstract java.nio.ByteBuffer putDouble(double d);
  public abstract double getDouble(int p);
  public abstract java.nio.ByteBuffer putDouble(int p, double d);
  public abstract java.nio.DoubleBuffer asDoubleBuffer();
  public java.lang.Object array();
  // public int compareTo(java.lang.Object o); // FIXME?
}
