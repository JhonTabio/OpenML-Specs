// Copyright (C) 2002 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with GNU Emacs; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package java.util;

/** JML's specification of java.util.Map.
 * @version $Revision: 2120 $
 * @author Katie Becker
 * @author Gary T. Leavens
 * @author David R. Cok
 */
//@ non_null_by_default
public interface Map<K,V> {
    /*@ public normal_behavior
      @   ensures \result == ( o == oo ||
      @        ( o != null && oo != null && o.equals(oo)));
      @ static public model pure boolean nullequals(Object o, Object oo);
      @*/

    
    public static interface Entry<K,V> {

        //@ public model instance K abstractKey;
        //@ public model instance V abstractValue;
        
        /*@  public normal_behavior
          @     ensures \result == abstractKey;
          @*/
        /*@ pure @*/ K getKey();

        /*@  public normal_behavior
          @     ensures \result == abstractValue;
          @*/
        /*@ pure @*/ V getValue();
        
        /*@ public behavior
          @     assignable this.abstractValue;
          @     ensures \result == \old(this.abstractValue);
          @     ensures this.abstractValue == value;
          @
          @     signals_only NullPointerException, UnsupportedOperationException,
                               ClassCastException, IllegalArgumentException;
          @*/
        V setValue(V value);

        /*@  also
          @   public normal_behavior
          @     requires o instanceof Entry;
          @     ensures !\key("RAC") ==> \result ==  ( this == o ||
          @      (    nullequals(((Entry)o).abstractKey, abstractKey)
          @        && nullequals(((Entry)o).abstractValue, abstractValue) ));
          @  also
          @   public normal_behavior
          @     requires !(o instanceof Entry);
          @     ensures \result == false;
          @*/
        /*@ pure @*/ boolean equals(Object o);

        /*@ pure @*/ int hashCode();

        /*@ public normal_behavior
          @   ensures !\key("RAC") ==> \result <==> (nullequals(abstractKey,key) &&
          @                         nullequals(abstractValue, value));
          @ public pure model boolean equals(Object key, Object value);
          @
          @
          @ public normal_behavior
          @   ensures \result <==> (abstractKey == key &&
          @                         abstractValue == value);
          @ public pure model boolean equalsObjects(Object key, Object value);
          @
          @
          @ public normal_behavior
          @   ensures \result <==> equalsObjects(e.getKey(),e.getValue());
          @ public pure model boolean equals(Entry e);
          @*/
    }

    //@ model public instance map<Object,V> modelMap; in objectState;
    // @ model public instance Entry<K,V>[] values; in objectState;
    //@ model public instance K[] keys; in objectState;
    
    /*@ public normal_behavior
          ensures \result <==> (\exists int i; 0<=i<keys.length; keys[i] == o);
          pure
        model public boolean hasKey(Object o);
      @*/

    /* @ public normal_behavior
          ensures \result <==> (\exists int i; 0<=i<v.length; v[i].getKey() == o);
          pure
        model public boolean hasKey(Entry<K,V>[] v, Object o);
      @*/

    /* @ public normal_behavior
          ensures \result <==> (\exists int i; 0<=i<values.length; values[i].getValue() == o);
          pure
        model public boolean hasValue(Object o);
      @*/

    /*@ public normal_behavior
          ensures \result == modelMap.get(o);
          //ensures (\forall int i; 0<=i<values.length; values[i].abstractKey != o) ==> \result == null;
          //ensures (\forall int i; 0<=i<values.length; values[i].abstractKey == o ==> values[i].abstractValue == \result);
          pure nullable
        model public V getmodel(Object o);
      @*/
      
    /*@
        public normal_behavior
          ensures \result <==> ( 
             isEmpty() 
             );
        model pure public boolean initialMap();
    @*/
      

    //@ public normal_behavior
    //-RAC@   ensures \result == keys.length;
    /*@ pure @*/
    int size();

    /*-RAC@ public normal_behavior
      @    ensures \result <==> (keys.length == 0); 
      @*/
    /*@ pure @*/ boolean isEmpty();
    
    /*-RAC@ public behavior
      @    ensures isEmpty() ==> !\result;
      @    ensures hasKey(key) <==> \result;
      @
      @    signals_only ClassCastException, NullPointerException;
      @    signals (ClassCastException)
      @         (* if the value is not appropriate for this object *);
      @    signals (NullPointerException) key == null
      @         && (* this type doesn't permit null values *);
      @*/
    /*@ pure @*/ boolean containsKey(Object key) throws RuntimeException;

    /*-RAC@ public behavior
      @    ensures isEmpty() ==> !\result;
      @    //ensures \result <==> hasValue(value);
      @
      @    signals_only ClassCastException, NullPointerException;
      @    signals (ClassCastException)
      @         (* if the value is not appropriate for this object *);
      @    signals (NullPointerException) value == null
      @         && (* this type doesn't permit null values *);
      @*/
    /*@ pure @*/ boolean containsValue(Object value);

    /*-RAC@ public normal_behavior
      @    requires !hasKey(key);
      @    ensures \result == null;
      @ also public normal_behavior
      @    requires hasKey(key);
      @    ensures \result == modelMap.get(key); //getmodel(key);
       
           // FIXME - exceptions?
      @*/
    /*@ pure nullable @*/ V get(/*@ nullable */ Object key);

    /*-RAC@ public normal_behavior
      @    // requires containsNull || (key != null && value != null);
      @    assignable modelMap;
      @    ensures modelMap == \old(modelMap).put(key,value);
      @    ensures hasKey(key);
      @    ensures modelMap.get(key) == value;
      @    ensures \result == \old(modelMap).get(key);
      @    //ensures \forall int i; 0<=i<\old(values).length; hasKey(values[i].getKey());
      @    ensures \forall int i; 0<=i<keys.length; keys[i] == key || hasKey(\old(keys));
      @     // FIXME: Need to state that the map values are unchanged
      @*/
    /* FIXME @
      @ also exceptional_behavior
      @    signals (NullPointerException) \not_modified(value)
      @             && (key==null)||(value==null) && !containsNull;
      @    signals (UnsupportedOperationException) \not_modified(theMap) 
      @             && (* if the map's put operation is not supported  *);
      @    signals (ClassCastException) \not_modified(theMap)
      @             && (* \typeof(key) or \typeof(value) is incompatible
      @                with the corresponding V or K type *);
      @    signals (IllegalArgumentException) \not_modified(theMap)
      @             && (* if some aspect of key or value is not 
      @                allowed in the map *);
      @*/
    /*@ nullable */V put(/*@ nullable */ K key, /*@ nullable */ V value);

    /*-RAC@ public behavior
      @    assignable objectState;
      @    ensures !hasKey(key);
      @    // FIXME - rest is unchanged
      @*/
    /*@ // FIXME
      @    signals_only ClassCastException, NullPointerException,
                               UnsupportedOperationException;
      @    signals (UnsupportedOperationException)
      @              (* if this operation is not supported *);
      @    signals (ClassCastException)
      @              (* if the argument is not appropriate *);
      @    signals (NullPointerException) key == null
      @              && (* if this map doesn't support null keys *);
      @*/
    V remove(Object key);

    /*@ public behavior
           requires t != null;
           assignable objectState;
           //ensures \old(isEmpty() && t.isEmpty()) <==> isEmpty();
           //ensures (\forall Object k; \old(t.containsKey(k) || containsKey(k)) 
           //                            <==> containsKey(k));
           //ensures (\forall Object k; \old(t.containsKey(k)) ==>  
           //                                   t.get(k) == get(k));
           //ensures (\forall Object k; \old(containsKey(k) && !t.containsKey(k))
           //                                   ==> get(k) == \old(get(k)));
        also public exceptional_behavior
           requires t == null;
           assignable \nothing;
           signals_only NullPointerException;
      @*/
     /*  FIXME
      @    signals (NullPointerException) \not_modified(theMap)
      @             && (t == null);
      @    signals (UnsupportedOperationException) \not_modified(theMap) 
      @             && (* if the map's put operation is not supported  *);
      @    signals (ClassCastException) \not_modified(theMap)
      @             && (* \typeof(t) or is incompatible
      @                with this map *);
      @    signals (IllegalArgumentException) \not_modified(theMap)
      @             && (* if some aspect of a key or value is not 
      @                allowed in the map *);
      @*/
    void putAll(Map<? extends K, ? extends V> t);

    /*-RAC@ public normal_behavior
      @    assignable objectState;
      @    ensures isEmpty();
      @*/
    void clear();
    
    //@ model public instance Set<K> _keySet; in objectState; // For determinism

    //@ public normal_behavior 
    //@    ensures \result != null;
    //@    ensures \result.size() >= 0; // FIXME - why needed?
    //@    ensures \result == _keySet;
    //@    ensures \forall K k;; \result.contains(k) <==> this.hasKey(k) ;
    /*@ pure @*/ Set<K> keySet(); // FIXME - do two calls of keySet produce different objects or the same?

    /*-RAC@ public normal_behavior 
      @    ensures \result != null;
      @    ensures \result.size() == keys.length;
           // FIXME
      @*/
    /*@ pure @*/ Collection<V> values();

    /*-RAC@ public normal_behavior
      @    ensures \result != null; 
      @    ensures \result.size() == keys.length;
           // FIXME
      @*/
    /*@ pure @*/ Set<Entry<K,V>> entrySet();

    /*@
      @ also
      @  public normal_behavior
      @    requires (o instanceof Map);
      @    ensures true;  // FIXME
      @ also public normal_behavior
      @    requires !(o instanceof Map);
      @    ensures !\result;
      @*/
    /*@ pure @*/ boolean equals(Object o);
    
    /*@ pure @*/ int hashCode();
}
